package se.uu.ub.cora.metacreator.recordtype;

import se.uu.ub.cora.data.DataGroup;
import se.uu.ub.cora.data.DataProvider;
import se.uu.ub.cora.data.DataRecordGroup;
import se.uu.ub.cora.data.DataRecordLink;
import se.uu.ub.cora.spider.dependency.SpiderInstanceProvider;
import se.uu.ub.cora.spider.extendedfunctionality.ExtendedFunctionality;
import se.uu.ub.cora.spider.extendedfunctionality.ExtendedFunctionalityData;
import se.uu.ub.cora.spider.record.RecordCreator;
import se.uu.ub.cora.spider.record.RecordReader;
import se.uu.ub.cora.storage.RecordNotFoundException;

public class RecordTypeCreateGroupsExtFunc implements ExtendedFunctionality {

	private DataRecordGroup recordGroup;

	private GroupFactory groupFactory;
	private RecordReader recordReader;
	private RecordCreator recordCreator;
	private String authToken;
	private String dataDivider;
	private String recordTypeId;

	private static final String METADATA_ID = "metadataId";
	private static final String NEW_METADATA_ID = "newMetadataId";
	private static final String METADATA_GROUP = "metadataGroup";
	private static final boolean EXCLUDE_P_GROUP_CREATION = true;

	private RecordTypeCreateGroupsExtFunc(GroupFactory groupFactory) {
		this.groupFactory = groupFactory;
		recordReader = SpiderInstanceProvider.getRecordReader();
		recordCreator = SpiderInstanceProvider.getRecordCreator();
	}

	public static RecordTypeCreateGroupsExtFunc usingGroupFactory(
			GroupFactory groupFactory) {
		return new RecordTypeCreateGroupsExtFunc(groupFactory);
	}

	@Override
	public void useExtendedFunctionality(ExtendedFunctionalityData data) {
		readAndConvertDataFromExtendednFunctionality(data);

		readIdAndDataDivider();
		possiblyCreateMetadataGroup(METADATA_ID, "recordInfoGroup");
		possiblyCreateMetadataGroup(NEW_METADATA_ID, decidedIdForRecordInfoNew());
	}

	private void readAndConvertDataFromExtendednFunctionality(ExtendedFunctionalityData data) {
		this.authToken = data.authToken;
		recordGroup = DataProvider.createRecordGroupFromDataGroup(data.dataGroup);
	}

	private void readIdAndDataDivider() {
		recordTypeId = recordGroup.getId();
		dataDivider = recordGroup.getDataDivider();
	}

	private String decidedIdForRecordInfoNew() {
		if (idIsAutoGenerated()) {
			return "recordInfoAutogeneratedNewGroup";
		}
		return "recordInfoNewGroup";
	}

	private boolean idIsAutoGenerated() {
		return "false".equals(recordGroup.getFirstAtomicValueWithNameInData("userSuppliedId"));
	}

	private void possiblyCreateMetadataGroup(String groupId, String childReference) {
		String metadataId = getLinkedRecordIdFromGroupByNameInData(groupId);
		if (recordDoesNotExistInStorage("metadata", metadataId)) {
			createAndStoreMetadataGroup(metadataId, childReference);
		}
	}

	private String getLinkedRecordIdFromGroupByNameInData(String textIdToExtract) {
		DataRecordLink link = recordGroup.getFirstChildOfTypeAndName(DataRecordLink.class,
				textIdToExtract);
		return link.getLinkedRecordId();
	}

	private boolean recordDoesNotExistInStorage(String recordType, String id) {
		try {
			recordReader.readRecord(authToken, recordType, id);
			return false;
		} catch (RecordNotFoundException e) {
			return true;
		}
	}

	private void createAndStoreMetadataGroup(String metadataId, String refToRecordInfo) {
		DataGroup dataGroupToStore = createMetadataGroup(metadataId, refToRecordInfo);
		storeMetadataGroup(METADATA_GROUP, dataGroupToStore);
	}

	private DataGroup createMetadataGroup(String metadataId, String refToRecordInfo) {
		DataRecordGroup metadataGroup = groupFactory.factorMetadataGroup(dataDivider, metadataId,
				recordTypeId, refToRecordInfo, EXCLUDE_P_GROUP_CREATION);
		return DataProvider.createGroupFromRecordGroup(metadataGroup);
	}

	private void storeMetadataGroup(String type, DataGroup dataGroup) {
		recordCreator.createAndStoreRecord(authToken, type, dataGroup);
	}
}
